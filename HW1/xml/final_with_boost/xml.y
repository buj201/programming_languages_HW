%{
#include <iostream>
#include <algorithm>
#include <string>
#include <boost/regex.hpp>

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.

void yyerror(const char *p) { std::cout << "Invalid" << std::endl; exit(1);}

void tagcompare (char *a, char *b)
{
    std::string openstr;
    openstr.append(a);
    boost::regex reopen ("<[ ]*");
    std::string newopen = "<";
    std::string openresult;
    openresult = boost::regex_replace(openstr, reopen, newopen);
    std::size_t foundopen = openresult.find_first_of(" >");
    openresult = openresult.substr(1,foundopen-1);
    std::transform(openresult.begin(), openresult.end(), openresult.begin(), ::tolower);

    std::string closestr;
    closestr.append(b);
    boost::regex reclose ("</[ ]*");
    std::string newclose = "</";
    std:: string closeresult;
    closeresult = boost::regex_replace(closestr, reclose, newclose);
    std::size_t foundclose = closeresult.find_first_of(" >");
    closeresult = closeresult.substr(2, foundclose-2);
    std::transform(closeresult.begin(), closeresult.end(), closeresult.begin(), ::tolower);

    if (openresult.compare(closeresult) != 0){
      std::cout << "Invalid" << std::endl; exit(1);
    }
}
%}

%union {
    char *strval;
};

%start prog

%token <strval> OPENINGTAG
%token <strval> CLOSINGTAG

%type <strval> matches

%%

prog: matches {/* Do nothing since correct input handled in main() */}
    ;

matches: OPENINGTAG matches CLOSINGTAG          { tagcompare($1, $3) ;}
    | OPENINGTAG CLOSINGTAG                     { tagcompare($1, $2) ;}
    | matches OPENINGTAG CLOSINGTAG             { tagcompare($2, $3) ;}
    | matches OPENINGTAG matches CLOSINGTAG     { tagcompare($2, $4) ;}
    ;

%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    std::cout << "Valid" << std:: endl; // yyparse() returning indicates valid XML
    return 0;
}
