%{
#include <iostream>
#include <algorithm>
#include <string>
#include <regex>

using namespace std;

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.

void yyerror(const char *p) { cout << "Invalid" << endl; exit(1);}

void tagcompare (char *a, char *b)
{
    string openstr;
    openstr.append(a);
    regex reopen ("<[ ]*");
    string newopen = "<";
    string openresult;
    openresult = regex_replace(openstr, reopen, newopen);
    size_t foundopen = openresult.find_first_of(" >");
    openresult = openresult.substr(1,foundopen-1);
    transform(openresult.begin(), openresult.end(), openresult.begin(), ::tolower);

    string closestr;
    closestr.append(b);
    regex reclose ("</[ ]*");
    string newclose = "</";
    string closeresult;
    closeresult = regex_replace(closestr, reclose, newclose);
    size_t foundclose = closeresult.find_first_of(" >");
    closeresult = closeresult.substr(2, foundclose-2);
    transform(closeresult.begin(), closeresult.end(), closeresult.begin(), ::tolower);

    if (openresult.compare(closeresult) != 0){
      cout << "Invalid" << endl; exit(1);
    }
}
%}

%union {
    char *strval;
};

%start prog

%token <strval> OPENINGTAG
%token <strval> CLOSINGTAG

%type <strval> matches

%%

prog: matches {/* Do nothing since correct input handled in main() */}
    ;

matches: OPENINGTAG matches CLOSINGTAG          { tagcompare($1, $3) ;}
    | OPENINGTAG CLOSINGTAG                     { tagcompare($1, $2) ;}
    | matches OPENINGTAG CLOSINGTAG             { tagcompare($2, $3) ;}
    | matches OPENINGTAG matches CLOSINGTAG     { tagcompare($2, $4) ;}
    ;

%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    cout << "Valid" << endl; // yyparse() returning indicates valid XML
    return 0;
}
